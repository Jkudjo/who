#!/bin/bash

# SSH Security Monitor & IP Banning System
# Enhanced version with comprehensive security features
# Author: Enhanced SSH Security Tool
# Version: 2.0

set -euo pipefail  # Strict error handling

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Configuration
readonly CONFIG_FILE="/etc/ssh-monitor.conf"
readonly DEFAULT_LOGFILE="/var/log/auth.log"
readonly DEFAULT_THRESHOLD=3
readonly DEFAULT_BANNED_LOG="/var/log/ssh-banned.log"
readonly DEFAULT_WHITELIST_FILE="/etc/ssh-monitor-whitelist"
readonly DEFAULT_BLACKLIST_FILE="/etc/ssh-monitor-blacklist"
readonly DEFAULT_GEOIP_TIMEOUT=5
readonly DEFAULT_REPORT_FILE="/var/log/ssh-monitor-report.log"

# Global variables
LOGFILE="$DEFAULT_LOGFILE"
THRESHOLD="$DEFAULT_THRESHOLD"
BANNED_LOG="$DEFAULT_BANNED_LOG"
WHITELIST_FILE="$DEFAULT_WHITELIST_FILE"
BLACKLIST_FILE="$DEFAULT_BLACKLIST_FILE"
GEOIP_TIMEOUT="$DEFAULT_GEOIP_TIMEOUT"
REPORT_FILE="$DEFAULT_REPORT_FILE"
ENABLE_GEOIP=true
ENABLE_BANNING=true
ENABLE_REPORTING=true
QUIET_MODE=false
JSON_OUTPUT=false
DAEMON_MODE=false
WATCH_INTERVAL=300  # 5 minutes

# Logging function
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$level" in
        "INFO") echo -e "${GREEN}[INFO]${NC} $timestamp: $message" ;;
        "WARN") echo -e "${YELLOW}[WARN]${NC} $timestamp: $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $timestamp: $message" ;;
        "DEBUG") [[ "${DEBUG:-false}" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} $timestamp: $message" ;;
    esac
    
    # Write to report file if enabled
    if [[ "$ENABLE_REPORTING" == "true" ]]; then
        echo "[$level] $timestamp: $message" >> "$REPORT_FILE"
    fi
}

# Error handling
error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run as root for iptables operations"
    fi
}

# Load configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        log "INFO" "Loading configuration from $CONFIG_FILE"
        source "$CONFIG_FILE"
    else
        log "WARN" "Configuration file not found, using defaults"
        create_default_config
    fi
}

# Create default configuration
create_default_config() {
    cat > "$CONFIG_FILE" << EOF
# SSH Monitor Configuration
LOGFILE="$DEFAULT_LOGFILE"
THRESHOLD=$DEFAULT_THRESHOLD
BANNED_LOG="$DEFAULT_BANNED_LOG"
WHITELIST_FILE="$DEFAULT_WHITELIST_FILE"
BLACKLIST_FILE="$DEFAULT_BLACKLIST_FILE"
GEOIP_TIMEOUT=$DEFAULT_GEOIP_TIMEOUT
REPORT_FILE="$DEFAULT_REPORT_FILE"
ENABLE_GEOIP=true
ENABLE_BANNING=true
ENABLE_REPORTING=true
WATCH_INTERVAL=300
EOF
    log "INFO" "Created default configuration at $CONFIG_FILE"
}

# Validate configuration
validate_config() {
    [[ -f "$LOGFILE" ]] || error_exit "Log file $LOGFILE does not exist"
    [[ -w "$LOGFILE" ]] || error_exit "Cannot read log file $LOGFILE"
    [[ "$THRESHOLD" =~ ^[0-9]+$ ]] || error_exit "Invalid threshold value: $THRESHOLD"
    [[ "$GEOIP_TIMEOUT" =~ ^[0-9]+$ ]] || error_exit "Invalid geoip timeout: $GEOIP_TIMEOUT"
}

# Check dependencies
check_dependencies() {
    local deps=("grep" "awk" "sort" "uniq" "iptables")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        error_exit "Missing dependencies: ${missing[*]}"
    fi
    
    # Optional dependency check
    if ! command -v "geoiplookup" &> /dev/null; then
        log "WARN" "geoiplookup not found, geographic information will be disabled"
        ENABLE_GEOIP=false
    fi
}

# Extract IP addresses with improved regex
extract_ips() {
    local pattern="$1"
    local time_filter="$2"
    
    if [[ -n "$time_filter" ]]; then
        grep -Ei "$pattern" "$LOGFILE" | grep "$time_filter" | grep -Eo "([0-9]{1,3}\.){3}[0-9]{1,3}" | sort -u
    else
        grep -Ei "$pattern" "$LOGFILE" | grep -Eo "([0-9]{1,3}\.){3}[0-9]{1,3}" | sort -u
    fi
}

# Enhanced geographic information with timeout and caching
geo_info() {
    local ip="$1"
    
    if [[ "$ENABLE_GEOIP" != "true" ]]; then
        echo "  IP: $ip"
        return
    fi
    
    # Check if IP is private/local
    if [[ "$ip" =~ ^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.|169\.254\.) ]]; then
        echo "  IP: $ip  🏠 Local/Private"
        return
    fi
    
    # Use timeout to prevent hanging
    local country
    country=$(timeout "$GEOIP_TIMEOUT" geoiplookup "$ip" 2>/dev/null | awk -F ': ' '{print $2}' | xargs)
    
    if [[ -n "$country" && "$country" != "IP Address not found" ]]; then
        echo "  IP: $ip  🌍 $country"
    else
        echo "  IP: $ip  🌐 Unknown"
    fi
}

# Check if IP is whitelisted
is_whitelisted() {
    local ip="$1"
    [[ -f "$WHITELIST_FILE" ]] && grep -q "^$ip$" "$WHITELIST_FILE"
}

# Check if IP is blacklisted
is_blacklisted() {
    local ip="$1"
    [[ -f "$BLACKLIST_FILE" ]] && grep -q "^$ip$" "$BLACKLIST_FILE"
}

# Enhanced IP banning with chain management
ban_ip() {
    local ip="$1"
    local reason="$2"
    
    if [[ "$ENABLE_BANNING" != "true" ]]; then
        log "INFO" "Banning disabled, would ban IP: $ip ($reason)"
        return
    fi
    
    # Check if already banned
    if iptables -L INPUT -v -n | grep -q "$ip"; then
        log "DEBUG" "IP $ip is already banned"
        return
    fi
    
    # Check whitelist
    if is_whitelisted "$ip"; then
        log "WARN" "IP $ip is whitelisted, skipping ban"
        return
    fi
    
    # Add to blacklist file
    if [[ -f "$BLACKLIST_FILE" ]]; then
        echo "$ip" >> "$BLACKLIST_FILE"
    fi
    
    # Create SSH-MONITOR chain if it doesn't exist
    if ! iptables -L SSH-MONITOR &>/dev/null; then
        iptables -N SSH-MONITOR
        iptables -I INPUT -j SSH-MONITOR
    fi
    
    # Add ban rule
    iptables -A SSH-MONITOR -s "$ip" -j DROP
    
    log "INFO" "🚫 Banned IP: $ip ($reason)"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - BANNED: $ip - $reason" >> "$BANNED_LOG"
}

# Unban IP
unban_ip() {
    local ip="$1"
    
    # Remove from iptables
    iptables -D SSH-MONITOR -s "$ip" -j DROP 2>/dev/null || true
    
    # Remove from blacklist file
    if [[ -f "$BLACKLIST_FILE" ]]; then
        sed -i "/^$ip$/d" "$BLACKLIST_FILE"
    fi
    
    log "INFO" "✅ Unbanned IP: $ip"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - UNBANNED: $ip" >> "$BANNED_LOG"
}

# Generate statistics
generate_stats() {
    local stats_file="/tmp/ssh-monitor-stats-$$.json"
    
    cat > "$stats_file" << EOF
{
  "timestamp": "$(date -Iseconds)",
  "logfile": "$LOGFILE",
  "threshold": $THRESHOLD,
  "successful_logins": $(extract_ips "Accepted password|Accepted publickey" | wc -l),
  "failed_attempts": $(extract_ips "Failed password|Invalid user" | wc -l),
  "disconnections": $(extract_ips "Disconnected from" | wc -l),
  "banned_ips": $(iptables -L SSH-MONITOR -n 2>/dev/null | grep DROP | wc -l),
  "whitelisted_ips": $([[ -f "$WHITELIST_FILE" ]] && wc -l < "$WHITELIST_FILE" || echo 0),
  "blacklisted_ips": $([[ -f "$BLACKLIST_FILE" ]] && wc -l < "$BLACKLIST_FILE" || echo 0)
}
EOF
    
    if [[ "$JSON_OUTPUT" == "true" ]]; then
        cat "$stats_file"
    fi
}

# Show help
show_help() {
    cat << EOF
SSH Security Monitor & IP Banning System v2.0

Usage: $0 [OPTIONS]

OPTIONS:
    -c, --config FILE     Configuration file (default: $CONFIG_FILE)
    -l, --logfile FILE    SSH log file (default: $DEFAULT_LOGFILE)
    -t, --threshold NUM   Failed attempts threshold (default: $DEFAULT_THRESHOLD)
    -b, --ban-log FILE    Banned IPs log file (default: $DEFAULT_BANNED_LOG)
    -w, --whitelist FILE  Whitelist file (default: $DEFAULT_WHITELIST_FILE)
    -k, --blacklist FILE  Blacklist file (default: $DEFAULT_BLACKLIST_FILE)
    -r, --report FILE     Report log file (default: $DEFAULT_REPORT_FILE)
    -d, --daemon          Run in daemon mode (continuous monitoring)
    -i, --interval SEC    Daemon interval in seconds (default: 300)
    -j, --json            Output statistics in JSON format
    -q, --quiet           Quiet mode (minimal output)
    --no-geoip           Disable geographic IP lookup
    --no-ban             Disable automatic IP banning
    --no-report          Disable report logging
    -u, --unban IP       Unban specific IP address
    -s, --stats          Show statistics only
    -h, --help           Show this help message

EXAMPLES:
    $0                    # Run with default settings
    $0 -d -i 60          # Run as daemon with 1-minute intervals
    $0 -u 192.168.1.100  # Unban specific IP
    $0 -s -j             # Show statistics in JSON format
    $0 --no-ban          # Monitor without banning

CONFIGURATION:
    Create $CONFIG_FILE to customize settings permanently.
    Whitelist IPs by adding them to $WHITELIST_FILE (one per line).
    Blacklist IPs by adding them to $BLACKLIST_FILE (one per line).

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -c|--config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            -l|--logfile)
                LOGFILE="$2"
                shift 2
                ;;
            -t|--threshold)
                THRESHOLD="$2"
                shift 2
                ;;
            -b|--ban-log)
                BANNED_LOG="$2"
                shift 2
                ;;
            -w|--whitelist)
                WHITELIST_FILE="$2"
                shift 2
                ;;
            -k|--blacklist)
                BLACKLIST_FILE="$2"
                shift 2
                ;;
            -r|--report)
                REPORT_FILE="$2"
                shift 2
                ;;
            -d|--daemon)
                DAEMON_MODE=true
                shift
                ;;
            -i|--interval)
                WATCH_INTERVAL="$2"
                shift 2
                ;;
            -j|--json)
                JSON_OUTPUT=true
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=true
                shift
                ;;
            --no-geoip)
                ENABLE_GEOIP=false
                shift
                ;;
            --no-ban)
                ENABLE_BANNING=false
                shift
                ;;
            --no-report)
                ENABLE_REPORTING=false
                shift
                ;;
            -u|--unban)
                check_root
                unban_ip "$2"
                exit 0
                ;;
            -s|--stats)
                generate_stats
                exit 0
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
    done
}

# Main monitoring function
monitor_ssh() {
    # Remove date filtering by setting current_time to empty
    local current_time=""
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        echo -e "${CYAN}=== 🚨 SSH Security Monitor v2.0 ===${NC}"
        echo -e "${CYAN}Timestamp: $(date)${NC}"
        echo -e "${CYAN}Log file: $LOGFILE${NC}"
        echo -e "${CYAN}Threshold: $THRESHOLD failed attempts${NC}"
        echo
    fi
    
    # Successful logins
    local successful_ips
    successful_ips=$(extract_ips "Accepted password|Accepted publickey" "$current_time")
    
    if [[ -n "$successful_ips" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "${GREEN}✅ Successful SSH logins:${NC}"
            echo "$successful_ips" | while read -r ip; do
                geo_info "$ip"
            done
            echo
        fi
    fi
    
    # Failed login attempts with enhanced detection
    local failed_attempts
    failed_attempts=$(extract_ips "Failed password|Invalid user|authentication failure" "$current_time" | sort | uniq -c)
    
    if [[ -n "$failed_attempts" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "${RED}❌ Failed SSH login attempts:${NC}"
        fi
        
        echo "$failed_attempts" | while read -r count ip; do
            if [[ "$QUIET_MODE" != "true" ]]; then
                geo_info "$ip"
                echo "    Attempts: $count"
            fi
            
            # Ban after 2 or more failed attempts
            if [[ "$count" -ge 2 ]]; then
                ban_ip "$ip" "Exceeded 2 failed attempts ($count total)"
            fi
        done
        
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo
        fi
    fi
    
    # Disconnected sessions
    local disconnected_ips
    disconnected_ips=$(extract_ips "Disconnected from|Connection closed" "$current_time")
    
    if [[ -n "$disconnected_ips" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "${YELLOW}🔌 Disconnected sessions:${NC}"
            echo "$disconnected_ips" | while read -r ip; do
                geo_info "$ip"
            done
            echo
        fi
    fi
    
    # Show current bans
    if [[ "$ENABLE_BANNING" == "true" ]]; then
        local banned_count
        banned_count=$(iptables -L SSH-MONITOR -n 2>/dev/null | grep DROP | wc -l || echo 0)
        
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "${PURPLE}🚫 Currently banned IPs: $banned_count${NC}"
        fi
    fi
    
    # Generate statistics if requested
    if [[ "$JSON_OUTPUT" == "true" ]]; then
        generate_stats
    fi
}

# Daemon mode
run_daemon() {
    log "INFO" "Starting SSH monitor daemon (interval: ${WATCH_INTERVAL}s)"
    
    while true; do
        monitor_ssh
        sleep "$WATCH_INTERVAL"
    done
}

# Main execution
main() {
    # Parse arguments first
    parse_args "$@"
    
    # Load configuration
    load_config
    
    # Validate configuration
    validate_config
    
    # Check dependencies
    check_dependencies
    
    # Check root privileges if banning is enabled
    if [[ "$ENABLE_BANNING" == "true" ]]; then
        check_root
    fi
    
    # Create necessary directories and files
    mkdir -p "$(dirname "$BANNED_LOG")"
    mkdir -p "$(dirname "$REPORT_FILE")"
    touch "$BANNED_LOG"
    touch "$REPORT_FILE"
    
    # Run in daemon mode or single execution
    if [[ "$DAEMON_MODE" == "true" ]]; then
        run_daemon
    else
        monitor_ssh
    fi
}

# Trap signals for clean exit
trap 'log "INFO" "SSH monitor stopped"; exit 0' SIGINT SIGTERM

# Run main function with all arguments
main "$@" 